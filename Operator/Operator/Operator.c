#define _CRT_SECURE_NO_WARNINGS  1

#include <stdio.h>

// 解決負數的方法
// 1. 將參數設成unsigned int
// 2. 將num & 1 比較最低位 每次比較完後右移來統計總共有多少1
// 3. n & (n-1)的方法 -- 有多少1循環幾次
int count_bit_one(unsigned int num) {
	int count = 0;
	/*while (num) {
		if (num % 2 == 1) {
			count++;
		}
		num /= 2;
	}*/

	/*for (int i = 0; i < 32; i++) {
		if ((num >> i & 1) == 1) {
			count++;
		}
	}*/

	while (num) {
		num = num & (num - 1);
		count++;
	}

	return count;
}

// 判斷 n是否為2的次方數 ( 用 n & (n-1) 的方法 )

void exp_2(int num) {
	if ((num & (num - 1)) == 0) {
		printf("%d是2的次方數", num);
	}
	else {
		printf("%d不是2的次方數", num);
	}
}


//int main() {
//
//	// & | ^ 例子
//
//	//int num1 = -3;
//	//// 3
//	////原碼 00000000 00000000 00000000 00000011
//	////反碼 11111111 11111111 11111111 11111100
//	////補碼 11111111 11111111 11111111 11111101 // -3
//	//int num2 = 5;
//	////原碼 00000000 00000000 00000000 00000101
//	////反碼 11111111 11111111 11111111 11111010
//	////補碼 11111111 11111111 11111111 11111011
//	//printf("%d\n", num1 & num2); // 00000000 00000000 00000000 00000101 -- 
//	//// 11111111 11111111 11111111 11111101 
//	//// 00000000 00000000 00000000 00000101
//	//printf("%d\n", num1 | num2); // 11111111 11111111 11111111 11111101 -- -3
//	//// 10000000 00000000 00000000 00000010
//	//// 10000000 00000000 00000000 00000011
//	//printf("%d\n", num1 ^ num2); // 11111111 11111111 11111111 11111000 -- -8
//	//// 10000000 00000000 00000000 00000111
//	//// 10000000 00000000 00000000 00001000
//	//printf("%d\n",~0); // -1
//
//	// 不能建立臨時變數（第三個變數），實現兩個整數的交換。
//
//	int a = 5;
//	int b = 3;
//
//	// a = a + b -- a = 8
//	// b = a - b -- b = 5
//	// a = a - b -- a = 3
//
//	a = a ^ b;
//	b = a ^ b;
//	a = a ^ b;
//
//	// 求一個整數存儲在內存中的二進制中1的個數
//	
//	int num = 0;
//
//	scanf("%d", &num);
//
//	//int result = count_bit_one(n);
//	//printf("%d的二進制總共有%d個1", n, result);
//		
//	exp_2(num);
//	return 0;
//}


// 編寫代碼碼將13⼆進位序列的第5個bit修改為1，然後再改回0

//int main() {
//
//	int a = 13;
//	// 00000000000000000000000000001101
//
//	int n = 5;
//	a = a | (1 << (n - 1));
//	printf("%d\n", a);
//
//	a &= ~(1 << (n - 1));
//
//	printf("%d\n", a);
//
//
//	return 0;
//}

// 整型提升

int main() {

	char a = 20;
	//
	// 00000000 00000000 00000000 00010100
	// 00010100 - a 
	//
	char b = 130;
	//
	// 00000000 00000000 00000000 10000010
	// 10000010 - b
	//
	char c = a + b;
	// 
	// 00000000 00000000 00000000 00010100 - a
	// 11111111 11111111 11111111 10000010 - b
	// 11111111 11111111 11111111 10010110 // 截斷
	// 10010110 - c

	// 補碼取反+1 -- 原碼
	// 11111111 11111111 11111111 10010110
	// 10000000 00000000 00000000 01101001
	// 10000000 00000000 00000000 01101010 -- 原碼

	// char類型取值範圍 : -128~127
	printf("%d\n", c); // -106


	return 0;
}